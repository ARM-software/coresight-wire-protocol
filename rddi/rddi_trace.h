/*
 * rddi_trace.h - Trace header for RDDI
 * Copyright (C) 2007,2017 Arm Limited. All rights reserved.
 */

/**  \file

     \brief This file describes the Trace functionality of the RDDI module.
*/

#ifndef RDDI_TRACE_H
#define RDDI_TRACE_H

#include "rddi.h"

#ifndef DOXYGEN_SHOULD_SKIP_THIS
/* 0x01XX - trace errors */


/** a comms error occurred between host and DSTREAM unit */
#define RDDI_TRACE_COMMSERROR                   0x0105

/** streaming trace operation not supported */
#define RDDI_TRACE_STREAM_UNSUPP                0x0109 

/** trace interface not initialized */
#define RDDI_TRACE_INTERFACE_NOT_INIT           0x010E

/** there is no trace data to collect */
#define RDDI_TRACE_NO_DATA                      0x0120

#define RDDI_TRACE_NO_TRIGGER                   0x0121

#endif



/**  \file

     This file describes the Trace functionality of the RDDI module along with
     the necessary definitions.
*/

/** Opaque handle for trace connection */
typedef int RDDITraceConnection;

/**
 * \enum RDDITraceEventType
 * \brief the types of event that may be delivered
 */
typedef enum 
{
    TRACE_DATA_DELIVERY,  /**< Delivers a quantity of data from a read request */
    TRACE_DATA_DELIVERY_FAILURE,  /**< Notifies failure of a read request */
    TRACE_STATUS,         /**< A status message */
    TRACE_OPAQUE_STATUS   /**< Generic status event, available for definition by 
                               implementations */
}
RDDITraceEventType;


/**
 * \enum RDDITraceStatus 
 * \brief These values reflect the status of the trace hardware. Values 
 *        are not mutually exclusive, e.g. trace capture may stopped AND the
 *        buffer may also be full.
 *
 *        These events are generated by RDDI in response to hardware messages.
 *        Certain generic events essential to trace control are defined here.
 *        The RDDI implementor may notify and document additional non-portable
 *        status bits.  For example, the DSTREAM implementation provides a 
 *        header (rddi_trace_dstream.h) which documents additional status bits
 *        for errors.

 *        TRACE_STATUS_TRIGGERED indicates that the trace hardware has 
 *        detected a trigger.  This will only be sent, if at all, some time 
 *        after a call to \ref Trace_Start().  Clients should check that this
 *        bit is set before calling \ref Trace_LocateTrigger().  It is the
 *        client's responsibility to ensure that that trace is stopped
 *        before the trigger is overwritten by new data.
 *
 *        TRACE_STATUS_STOPPED indicates that trace collection has stopped.
 *        After a successful call to Trace_Start(), RDDI will send an RDDITraceStatus
 *        event with the TRACE_STATUS_STOPPED bit clear.  This indicates that the
 *        trace hardware has accepted the start request.  Should trace collection
 *        eventually stop, RDDI will send an RDDITraceStatus event with the
 *        TRACE_STATUS_STOPPED bit set.  Trace collection will stop after a 
 *        successful call to Trace_Stop().  If the trace hardware supports it,
 *        trace collection may also stop spontaneously if some criterion is met.
 *        For example, the DSTREAM trace hardware can be configured to stop 
 *        collecting trace on detecting a trigger, or when the physical buffer fills.
 *
 *        TRACE_STATUS_WRAPPED may be sent some time after a successful call to
 *        Trace_Start(), if the trace hardware supports a circular buffer.  It 
 *        indicates that the circular buffer has filled, and that the oldest collected
 *        trace data is being overwritten with newly collected data.  Note that
 *        TRACE_STATUS_WRAPPED high implies that TRACE_STATUS_FULL is high, but
 *        not vice versa.
 *
 *        TRACE_STATUS_GOTDATA may be sent some time after a successful call to
 *        Trace_Start().  It indicates that the trace hardware has collected some trace
 *        data.
 *
 *        TRACE_STATUS_FULL may be sent some time after a successful call to
 *        Trace_Start().  It indicates that the trace hardware has filled its 
 *        internal buffer.  What happens next will be determined by the RDDI 
 *        implementation and hardware configuration. 
 */
typedef enum
{
    TRACE_STATUS_TRIGGERED              = 0x00000001, /**< a trigger was hit */
    TRACE_STATUS_STOPPED                = 0x00000002, /**< Trace capture has stopped */
    TRACE_STATUS_WRAPPED                = 0x00000004, /**< The physical buffer wrapped */
    TRACE_STATUS_GOTDATA                = 0x00000100, /**< Some data is available to read */
    TRACE_STATUS_FULL                   = 0x00200000, /**< The buffer is full */
}
RDDITraceStatus;

/**
 * \struct RDDITraceDataDeliveryEvent
 * \brief Asynchronous event from the trace system returning data to the client.
 *  Note that the supplied buffer is only valid for the lifetime of the callback.
 *
 * See \ref Trace_RequestReadBlocks for further information.
 */
typedef struct
{
    RDDITraceEventType          type; /**< TRACE_DATA_DELIVERY */

    uint32                      startBlock; /**< The offset with the buffer that this data represents */
    uint32                      numBlocks; /**< The number of blocks in the buffer */
    uint32                      blockSize; /**< The number of bytes per block */
    const void                 *buffer; /**< The buffer of data (numBlocks * blockSize bytes) */
} RDDITraceDataDeliveryEvent;

/**
 * \struct RDDITraceDataDeliveryFailureEvent
 * \brief Asynchronous event notifying failure to complete a read request.
 *        At most one such event may be received for each call to 
 *        \ref Trace_RequestReadBlocks. If this happens, no more 
 *        \ref RDDITraceDataDeliveryEvent notifications will be received
 *        for that read request.  It is possible for some successful
 *        RDDITraceDataDeliveryEvent notifications to occur before
 *        the RDDITraceDataDeliveryFailureEvent notification.
 *
 * Note that the buffer supplying the message is only valid for the lifetime
 * of the callback.
 */
typedef struct
{
    RDDITraceEventType          type; /**< TRACE_DATA_DELIVERY_FAILURE */
    int                         errorCode; /**< RDDI error code */
    size_t                      messageLength; /**< length of message, including
                                                    terminating NUL character */
    const char                 *message; /**< not null */
} RDDITraceDataDeliveryFailureEvent;

/**
 * \struct RDDITraceStatusEvent
 * \brief The value of the status field in the status event will represent
 *        the trace status at the time of reporting. This field should be
 *        interpreted as a bitwise-OR of enumerator values of the enumeration 
 *        \ref RDDITraceStatus.
 */
typedef struct
{
    RDDITraceEventType          type; /**< TRACE_STATUS */
    int                         status; /**< a bitwise-OR-ed set of flags of 
                                            type RDDITraceStatus */
} RDDITraceStatusEvent;

/**
 * \struct RDDITraceOpaqueStatusEvent
 * \brief Available for use by RDDI implementations. 
 *  See \ref DSTREAM_Opaque_Events for details of the format ued by Arm
 *  implementation.
 */
typedef struct
{
    RDDITraceEventType          type; /**< implementors should set to 
                                           TRACE_OPAQUE_STATUS */

    size_t                      length; /**< length of the message in bytes */
    void                       *data; /**< a block of data, the contents of which
                                           is defined by the RDDI implementor */
} RDDITraceOpaqueStatusEvent;

/**
 * \union RDDITraceEvent
 * \brief Asynchronous event from the trace system.
 */
typedef union
{
    /** the common initial sequence shared by all trace events */
    struct
    {
        RDDITraceEventType   type;
    }
    common;

    /** specific events */
    RDDITraceDataDeliveryEvent              dataDelivery; /**< data delivery */
    RDDITraceDataDeliveryFailureEvent       dataDeliveryFailure; /**< 
                                                            delivery failure */
    RDDITraceStatusEvent                    status; /**< status event */
    RDDITraceOpaqueStatusEvent              opaqueStatus; /**< opaque status*/
} RDDITraceEvent;

/** Callback function for trace events.  
    <B>No RDDI functions are guaranteed to work
    correctly if called from a trace event callback.</B>
    Callback notifications are queued on a dedicated thread in the RDDI 
    library.  This allows clients to perform slow operations (for example, 
    writing trace output to a file) from the callback without blocking the 
    trace being read from the trace hardware.
*/
#ifdef __cplusplus
extern "C" {
#endif

typedef void (*TraceCallback)(void *pContext, const RDDITraceEvent* event);

#ifdef __cplusplus
}
#endif


/**
 * \enum RDDITraceConfigItemType
 * \brief the types of config item that are supported
 */
typedef enum
{
    TRACE_CONFIG_ITEM_TYPE_INTEGER,     /**< an integer */
    TRACE_CONFIG_ITEM_TYPE_RESERVED,    /**< reserved for use by Arm Limited */
    TRACE_CONFIG_ITEM_TYPE_STRING,      /**< a string */
    TRACE_CONFIG_ITEM_TYPE_ENUM,        /**< an enumerated type */
    TRACE_CONFIG_ITEM_TYPE_BOOLEAN      /**< a boolean */   
}
RDDITraceConfigItemType;


/**
    Opens a connection to the trace system. This must be done before any other
    trace functions can be called. 

    \param[in] handle Session handle previously created by RDDI_Open()
    \param[out] traceConn Returns a handle for the trace connection to be used
    in subsequent calls to trace interface functions.  The caller is responsible
    for disposing of the handle with Trace_Disconnect when the connection is
    no longer needed.
 */
RDDI int Trace_Connect(
    RDDIHandle           handle,
    RDDITraceConnection *traceConn);

/**
    An extended implementation of Trace_Connect() with additional configuration options.
    
    Opens a connection to the trace system. This must be done before any other
    trace functions can be called. 

    \param[in] handle Session handle previously created by RDDI_Open()
    \param[out] traceConn Returns a handle for the trace connection to be used
    in subsequent calls to trace interface functions.  The caller is responsible
    for disposing of the handle with Trace_Disconnect when the connection is
    no longer needed.
    \param[in] pConnInfo An optional string containing connection information.
    Parameters in the string are specified as <KEY>=<VALUE> and are comma separated.
    Supported keys are DEVICE and TRACETYPE. DEVICE specifies the trace device type
    to be used for the connection, and can be either DSTREAM or ULP (for ULINK Pro).
    TRACETYPE specifies the type of trace connection, and can be either SWO (for
    streaming SWO trace) or DSTREAM (for a 'standard' DSTREAM trace connection). An
    example pConnInfo string is "DEVICE=ULP,TRACETYPE=SWO". pConnInfo can be NULL for
    a trace connection with default parameters, as would be achieved using Trace_Connect().
    \param[in] pData An optional pointer to user supplied data associated with the
    trace connection. Set to NULL if there is no additional data.
    \param[in] dataLength The number of bytes of user supplied data
 */
RDDI int Trace_ConnectEx(
    RDDIHandle          handle,
    RDDITraceConnection *traceConn,
    char                *pConnInfo,
    void                *pData,
    size_t              dataLength);

/**
    Closes the connection to the trace box. A connection must successfully
    have been opened using Trace_Connect().

    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
 */
RDDI void Trace_Disconnect(RDDITraceConnection traceConn);

/**
    Returns identification details from the trace box, if any.
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[out] productCode Buffer to receive the product code of the trace box.
    This may be a null pointer if the information is not required.
    \param[in] productCodeLen If productCode is null, the parameter is ignored.
    Otherwise, it specifies the number of bytes available in the buffer.
    \param[out] productCodeUsed If productCode is null, returns the number of
    bytes which would have been needed in the buffer.  This provides a means
    for callers to determine the buffer size dynamically; no error is returned.
    Otherwise, the meaning of the returned value depends on whether the buffer
    was large enough.  If so, the returned value represents the number of bytes
    which were actually copied to the buffer.  If not, the value represents the
    number of bytes which would have been needed in the buffer, and the call
    returns the error RDDI_BUFFER_OVERFLOW.
    The buffer returns a NUL-terminated string.  The lengths supplied by and
    returned to the caller include the terminating NUL.    
    \param[out] details Buffer to receive detailed information about the trace
    box. The information is returned as an XML document, contents TBD.
    This may be a null pointer if the information is not required.
    \param[in] detailsLen If details is null, the parameter is ignored.
    Otherwise, it specifies the number of bytes available in the buffer.
    \param[out] detailsUsed If details is null, returns the number of
    bytes which would have been needed in the buffer.  This provides a means
    for callers to determine the buffer size dynamically; no error is returned.
    Otherwise, the meaning of the returned value depends on whether the buffer
    was large enough.  If so, the returned value represents the number of bytes
    which were actually copied to the buffer.  If not, the value represents the
    number of bytes which would have been needed in the buffer, and the call
    returns the error RDDI_BUFFER_OVERFLOW.
    The buffer returns a NUL-terminated string.  The lengths supplied by and
    returned to the caller include the terminating NUL.    
 */
RDDI int Trace_GetIdentity(
    RDDITraceConnection  traceConn,
    char                *productCode,
    unsigned int         productCodeLen,
    unsigned int        *productCodeUsed,
    char                *details,
    unsigned int         detailsLen,
    unsigned int        *detailsUsed
);

/**
    Returns trace capability details from the trace hardware.

    Currently unsupported.
*/

RDDI int Trace_GetCapabilities(
        RDDITraceConnection     traceConn,
        int                     blockID,
        uint32                 *pBlockData, 
        size_t                  blockDataLen,
        size_t                 *pBlockDataUsed);

/**
    Gets the size of a block for this trace hardware.  A block is the 
    smallest unit of trace data which the hardware is capable of 
    returning.  RDDI trace function parameters which represent 
    an address or amount of trace data are expressed in blocks.
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[out] blockSize Returns the size of a block in bytes.
 */
RDDI int Trace_GetBlockSize(
    RDDITraceConnection     traceConn,
    size_t                 *blockSize);

/**
    Starts trace collection.

    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
 */
RDDI int Trace_Start(RDDITraceConnection traceConn);

/**
    Stops trace collection.

    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
 */
RDDI int Trace_Stop(RDDITraceConnection traceConn);

/**
    Clears any trace from any storage buffer(s) and performs a reset on
    any trace capture hardware (if it supports it).

    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
 */
RDDI int Trace_Reset(RDDITraceConnection traceConn);

/**
    Locates the end of trace data, if any, else returns RDDI_TRACE_NO_DATA.
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()

    This function should only be called after:

    - the trace hardware has collected some trace data, indicated by an RDDITraceStatus
      event with the TRACE_STATUS_GOTDATA bit set,

    and

    - trace collection has stopped, indicated by an RDDITraceStatus event with 
      the TRACE_STATUS_STOPPED bit set.


    \param[out] block The (zero-based) number of the block containing the end of trace
    data.
    */
RDDI int Trace_LocateEndOfData(
    RDDITraceConnection     traceConn,
    uint32                 *block); 

/**
    Requests that the specified trace data be delivered.

    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[in] startBlock The position in the trace hardware buffer in blocks.
    \param[in] numBlocks The number of blocks to be returned.

    Prior to calling this function, callers <b>must</b> have set a
    \ref TraceCallback function for trace events using Trace_RegisterCallback().
    RDDI-Debug-RVI will only deliver data if the target hardware has a USB 2.0
    connection to the client machine.

    This function should only be called after:

    - the trace hardware has collected some trace data, indicated by an RDDITraceStatus
      event with the TRACE_STATUS_GOTDATA bit set,

    and

    - trace collection has stopped, indicated by an RDDITraceStatus event with 
      the TRACE_STATUS_STOPPED bit set.

    Use \ref Trace_LocateEndOfData() to determine the last valid block address.
    The sum (startBlock + numBlocks) should not exceed (last valid block address + 1).

    A single read request may result in multiple callbacks being made. The user
    should not rely on receiving a single large buffer. Data will be returned
    asynchronously via the RRDITraceDataDeliveryEvent event. If an error is detected
    any time after the Trace_RequestReadBlocks call has successfully returned,
    but before the the last block of data has been notified, the sequence of 
    RRDITraceDataDeliveryEvent callbacks will halt, and there will be a single 
    RDDITraceDataDeliveryFailureEvent event.

    The data pointer is valid only during the invocation of the callback function.

    If multiple calls are made to Trace_RequestRead then these will be honored
    in the order that they are received and callbacks generated for all calls.
 */

RDDI int Trace_RequestReadBlocks( 
    RDDITraceConnection    traceConn,
    uint32                 startBlock,
    uint32                 numBlocks);


/**
    Retrieves a list of supported configuration items from the trace box.

    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[out] configItems Buffer to take the list of supported configuration
    items. The list is formatted as a NUL-terminated string delimited by 
    newlines
    \param[in] configItemsLen Size of the client-supplied buffer in characters.
    Since the list of supported configuration items is NUL-terminated, this is
    one more than the number of characters that can be accommodated by the
    buffer. If the length is less than that required to accommodate the
    configuration items list, then the error RDDI_BUFFER_OVERFLOW is returned.
    \param[out] configItemsUsed If the return value is RDDI_BUFFER_OVERFLOW, 
    returns the size of buffer which would have been required to return the 
    complete result.  Otherwise, returns the number of characters written to
    the buffer including the terminating NUL.
 */
RDDI int Trace_GetConfigItems(
    RDDITraceConnection traceConn,
    char               *configItems,
    unsigned int        configItemsLen,
    unsigned int       *configItemsUsed);

/**
    Retrieves generic information about a particular configuration item.
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[in] name Item name as returned by Trace_GetConfigItems(), stripped
    of any newline delimiters.
    \param[out] type Returns the data type of the item
    \param[out] readonly Returns nonzero if the item is readonly.
    \param[out] visible Returns nonzero if the item is intended to be modified
    by trace clients.  A zero value here means that the item may enable test 
    modes or other behavior which would break typical clients.  A user 
    interface should probably ignore any item whose 'visible' attribute is
    zero.
    \param[out] displayName Buffer to receive a display name for the item, 
    suitable for presentation in a user interface.  
    This may be a null pointer if the information is not required.
    \param[in] displayNameLen If displayName is null, the parameter is ignored.
    Otherwise, it specifies the number of bytes available in the buffer.
    \param[out] displayNameUsed If displayName is null, returns the number of
    bytes which would have been needed in the buffer.  This provides a means
    for callers to determine the buffer size dynamically; no error is returned.
    Otherwise, the meaning of the returned value depends on whether the buffer
    was large enough.  If so, the returned value represents the number of bytes
    which were actually copied to the buffer.  If not, the value represents the
    number of bytes which would have been needed in the buffer, and the call
    returns the error RDDI_BUFFER_OVERFLOW.
    The buffer returns a NUL-terminated string.  The lengths supplied by and
    returned to the caller include the terminating NUL.    
    \param[out] helpString Buffer to receive a longer description of the item,
    suitable for presentation as help in a user interface. 
    \param[in] helpStringLen If helpString is null, the parameter is ignored.
    Otherwise, it specifies the number of bytes available in the buffer.
    \param[out] helpStringUsed If helpString is null, returns the number of
    bytes which would have been needed in the buffer.  This provides a means
    for callers to determine the buffer size dynamically; no error is returned.
    Otherwise, the meaning of the returned value depends on whether the buffer
    was large enough.  If so, the returned value represents the number of bytes
    which were actually copied to the buffer.  If not, the value represents the
    number of bytes which would have been needed in the buffer, and the call
    returns the error RDDI_BUFFER_OVERFLOW.
    The buffer returns a NUL-terminated string.  The lengths supplied by and
    returned to the caller include the terminating NUL.
 */
RDDI int Trace_GetConfigItemDetails(
    RDDITraceConnection       traceConn,
    const char               *name,
    RDDITraceConfigItemType  *type,
    int                      *readonly,
    int                      *visible,
    char                     *displayName,
    unsigned int              displayNameLen,
    unsigned int             *displayNameUsed,
    char                     *helpString,
    unsigned int              helpStringLen,
    unsigned int             *helpStringUsed);

/**
    Retrieves specific information about a configuration item.
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[in] name Item name as returned by Trace_GetConfigItems(), stripped
    of any newline delimiters.
    \param[out] value Buffer to receive the value of the item
    \param[in] valueLen If value is null, the parameter is ignored.
    Otherwise, it specifies the number of bytes available in the buffer.
    \param[out] valueUsed If value is null, returns the number of
    bytes which would have been needed in the buffer.  This provides a means
    for callers to determine the buffer size dynamically; no error is returned.
    Otherwise, the meaning of the returned value depends on whether the buffer
    was large enough.  If so, the returned value represents the number of bytes
    which were actually copied to the buffer.  If not, the value represents the
    number of bytes which would have been needed in the buffer, and the call
    returns the error RDDI_BUFFER_OVERFLOW.
    The buffer returns a NUL-terminated string.  The lengths supplied by and
    returned to the caller include the terminating NUL.
 */
RDDI int Trace_GetConfigItem(
    RDDITraceConnection       traceConn,
    const char               *name,
    char                     *value,
    unsigned int              valueLen,
    unsigned int             *valueUsed);

/**
    Sets the value of a configuration item.
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[in] name Item name as returned by Trace_GetConfigItems(), stripped
    of any newline delimiters.
    \param[in] value The new value of the item
 */
RDDI int Trace_SetConfigItem(
    RDDITraceConnection       traceConn,
    const char               *name,
    const char               *value);

/**
    Sets a callback to receive trace events.
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[in] callback A callback function to receive trace events.
    \param[in] pContext An optional pointer for arbitrary use by the client.
               The pointer will be passed back to the client as the pContext
               argument in each invocation of the callback function.
 */
RDDI int Trace_RegisterCallback(
    RDDITraceConnection       traceConn,
    TraceCallback             callback,
    void                     *pContext);

/**
    Gets information about the status of trace.
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[out] status Returns the status as a bitwise-OR-ed set of flags 
    see \ref RDDITraceStatus for the meaning of individual flags.
 */
RDDI int Trace_GetStatus(
    RDDITraceConnection traceConn,
    int                *status);

/**
    Gets the approximate location of the trigger in the buffer, if any, else
    returns RDDI_TRACE_NO_TRIGGER.  If more than one trigger occurred, only
    the first is located.  In some implementations, it may not be possible 
    to locate the trigger exactly: lowerBound and upperBound return the first
    and last blocks (inclusive) in which the trigger may be located.  
    If the implementation can locate the exact block, the bounds may coincide.

    This function should only be called after:

    - the trace hardware has detected a trigger, indicated by an RDDITraceStatus
      event with the TRACE_STATUS_TRIGGERED bit set,

    and

    - trace collection has stopped, indicated by an RDDITraceStatus event with 
      the TRACE_STATUS_STOPPED bit set.

    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[out] lowerBound the lower bound - expressed as a (zero-based) block number.
    \param[out] upperBound the upper bound - expressed as a (zero-based) block number.
 */
RDDI int Trace_LocateTrigger(
    RDDITraceConnection     traceConn,
    uint32                 *lowerBound,   
    uint32                 *upperBound); 

/** \page rddireturns RDDI Error Returns

\li <B>RDDI_TRACE_COMMSERROR</B> A comms error occurred between host and DSTREAM 
    unit.
\li <B>RDDI_TRACE_STREAM_UNSUPP</B> Streaming trace operation not supported 
\li <B>RDDI_TRACE_INTERFACE_NOT_INIT</B> The trace interface is not initialized 
\li <B>RDDI_TRACE_NO_DATA</B> Returned by Trace_LocateEndOfData() when there
is no trace data to collect.
\li <B>RDDI_TRACE_NO_TRIGGER</B> Returned by Trace_LocateTrigger() when no 
trigger has not been encountered.

 */

/**
    Perform an RDDI implementation specific transaction.
    
    \param[in] traceConn Trace connection handle previously created by
    Trace_Connect()
    \param[in] pDataIn data supplied by client for this transaction
    \param[in] dataInLen length in bytes of the data supplied by the client for
    this transaction
    \param[out] pDataOut Client-supplied buffer to take the results of the transaction
    \param[in] dataOutLen length in bytes of the data buffer supplied by the
    client for the results of this transaction
    \param[out] dataOutUsedLen The number of bytes of transaction data returned.
   
 */
RDDI int Trace_Transaction(
    RDDITraceConnection traceConn,
    const uint8* pDataIn,
    size_t dataInLen,
    uint8 *pDataOut,
    size_t dataOutLen,
    size_t* dataOutUsedLen);

#endif /* RDDI_TRACE_H */
/* end of file rddi_trace.h */
